(window.webpackJsonp=window.webpackJsonp||[]).push([[100],{496:function(e,s,n){"use strict";n.r(s);var t=n(1),a=Object(t.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("大家都听说过 http 的"),s("code",[e._v("keep-alive")]),e._v(", 不过 TCP 层面也是有"),s("code",[e._v("keep-alive")]),e._v("机制，而且跟应用层不太一样。")]),e._v(" "),s("p",[e._v("试想一个场景，当有一方因为网络故障或者宕机导致连接失效，由于 TCP 并不是一个轮询的协议，在下一个数据包到达之前，对端对连接失效的情况是一无所知的。")]),e._v(" "),s("p",[e._v("这个时候就出现了 keep-alive, 它的作用就是探测对端的连接有没有失效。")]),e._v(" "),s("p",[e._v("在 Linux 下，可以这样查看相关的配置:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("sudo sysctl -a | grep keepalive\n\n// 每隔 7200 s 检测一次\nnet.ipv4.tcp_keepalive_time = 7200\n// 一次最多重传 9 个包\nnet.ipv4.tcp_keepalive_probes = 9\n// 每个包的间隔重传间隔 75 s\nnet.ipv4.tcp_keepalive_intvl = 75\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br")])]),s("p",[e._v("不过，现状是大部分的应用并没有默认开启 TCP 的"),s("code",[e._v("keep-alive")]),e._v("选项，为什么？")]),e._v(" "),s("p",[e._v("站在应用的角度:")]),e._v(" "),s("ul",[s("li",[e._v("7200s 也就是两个小时检测一次，时间太长")]),e._v(" "),s("li",[e._v("时间再短一些，也难以体现其设计的初衷, 即检测长时间的死连接")])]),e._v(" "),s("p",[e._v("因此是一个比较尴尬的设计。")])])}),[],!1,null,null,null);s.default=a.exports}}]);