(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{280:function(e,v,t){"use strict";t.r(v);var p=t(13),_=Object(p.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("p",[e._v("大家都听说过 http 的"),v("code",[e._v("keep-alive")]),e._v(", 不过 TCP 层面也是有"),v("code",[e._v("keep-alive")]),e._v("机制，而且跟应用层不太一样。")]),e._v(" "),v("p",[e._v("试想一个场景，当有一方因为网络故障或者宕机导致连接失效，由于 TCP 并不是一个轮询的协议，在下一个数据包到达之前，对端对连接失效的情况是一无所知的。")]),e._v(" "),v("p",[e._v("这个时候就出现了 keep-alive, 它的作用就是探测对端的连接有没有失效。")]),e._v(" "),v("p",[e._v("在 Linux 下，可以这样查看相关的配置:")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("sudo sysctl -a | grep keepalive\n\n// 每隔 7200 s 检测一次\nnet.ipv4.tcp_keepalive_time = 7200\n// 一次最多重传 9 个包\nnet.ipv4.tcp_keepalive_probes = 9\n// 每个包的间隔重传间隔 75 s\nnet.ipv4.tcp_keepalive_intvl = 75\n")])])]),v("p",[e._v("不过，现状是大部分的应用并没有默认开启 TCP 的"),v("code",[e._v("keep-alive")]),e._v("选项，为什么？")]),e._v(" "),v("p",[e._v("站在应用的角度:")]),e._v(" "),v("ul",[v("li",[e._v("7200s 也就是两个小时检测一次，时间太长")]),e._v(" "),v("li",[e._v("时间再短一些，也难以体现其设计的初衷, 即检测长时间的死连接")])]),e._v(" "),v("p",[e._v("因此是一个比较尴尬的设计。")])])}),[],!1,null,null,null);v.default=_.exports}}]);